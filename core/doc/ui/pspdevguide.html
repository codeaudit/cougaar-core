<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (WinNT; I) [Netscape]">
   <title>COUGAAR PSP Developer's Guide</title>
</head>
<body>
<!--  ############################################################################ --><!--  ############################################################################ --><!--  ############################################################################ -->
<h1>
PlanServiceProvider Developer's Guide</h1>
<!--  ############################################################################ --><!--  ############################################################################ --><!--  ############################################################################ --><!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
Introduction</h2>
<!--  ############################################################################ --><!--  ############################################################################ -->
<p>The LogPlanServer is a light-weight COUGAAR Cluster PlugIn server which
provides the following categories of services:
<pre>+) It can handle a limited HTTP vocabulary&nbsp; (GET/POST).&nbsp;&nbsp;
+) It can act as a proxy to another LogPlanServer or webserver.
+) It is a framework for Plan Service Providers (PSPs);</pre>
The LogPlanServer passes LogPlan queries and update requests through to
Plan Service Providers for action. Plan Service Providers encapsulate the
"business rules" for answering requests and updates from UI clients, eg.
LEIF Producers, browsers, or an external service such as an Aggregation
server. The design approach is to encapsulate the application/domain knowledge
within PSPs, freeing the LogPlanServer to handle service requests in a
generic fashion.
<p>An incoming HTTP GET request is interpreted with respect to a set of
public keywords. These keywords either refer to a set of LogPlanServer
services, or are directed to Plan Service Providers. URL parameters which
are not recognized by the LogPlanServer are said to be private keywords.
These may be interpreted by Plan Service Providers as expressions of a
query or interaction language which is private to it and its application.
<br><!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
PSP Implementation Rules, in a Nutshell</h2>
<!--  ############################################################################ --><!--  ############################################################################ -->
<pre>PSP authorship, details, hints, tips

+) a PSP must implement the PlanServiceProvider.java interface&nbsp;
+) in addition, a "long-running" PSP must implement the KeepAlive.java interface ( marker )&nbsp;
+) a PSP which subscribes to changes (uses subscription API), must implement the UISubscriber.java interface&nbsp;
+) all PSPs must have a public zero parameter constructor defined.&nbsp;
+) extend the provided PSP_BaseAdapter.java -- greatly simplifies writing PSPs&nbsp;
+) if you plan to ONLY evoke your PSP by DIRECT REFERENCE (in URL form), don't need to implement test() method.&nbsp;

</pre>
<!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
Implementing a PSP</h2>
<!--  ############################################################################ --><!--  ############################################################################ --><!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
The PlanServiceProvider Interface</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<pre>public interface PlanServiceProvider
{
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; // The following methods do not require implementation if extending from PSP_BaseAdapter
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; abstract String getPath();
&nbsp;&nbsp;&nbsp; abstract void setResourceLocation(String path, String name) throws RuntimePSPException;
&nbsp;&nbsp;&nbsp; abstract void setResourceLocation(String path) throws RuntimePSPException;
&nbsp;&nbsp;&nbsp; abstract public boolean pathEqual(Vector resourcepath);

&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; //&nbsp; **Generally** can default to implementation provided by PSP_BaseAdapter.
&nbsp;&nbsp;&nbsp; //&nbsp; However, if PSP maintains private state which needs to be shared across
&nbsp;&nbsp;&nbsp; //&nbsp; all instances of PSP running (multiple clients), need to overload and provide clone.
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; abstract PlanServiceProvider pspClone() throws Exception;


&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; // test() does not require implementation in the majority case where PSPs
&nbsp;&nbsp;&nbsp; // are evoked by DIRECT REFERENCE, ala: http://localhost:5555/DEMO/MY.PSP
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; abstract public boolean test(HttpInput query_parameters, PlanServiceContext sc);

&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; //&nbsp; execute() is where most of work is performed.
&nbsp;&nbsp;&nbsp; //&nbsp; IMPLEMENTATION REQUIRED!
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; abstract public void execute( PrintStream out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpInput query_parameters,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PlanServiceContext psc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PlanServiceUtilities psu) throws Exception;

&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; // NON-CRITICAL!
&nbsp;&nbsp;&nbsp; // The following are not used at this point in time.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; //
&nbsp;&nbsp;&nbsp; abstract boolean returnsXML();
&nbsp;&nbsp;&nbsp; abstract boolean returnsHTML();
&nbsp;&nbsp;&nbsp; abstract String getDTD();
}

</pre>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Evoking PSPs -- 2 Approaches</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>A PSP can be evoked in two ways: by direct reference, or by "query testing".
Both forms are supported. However, for most applications, PSPs should be
evoked by direct reference -- as a resource of a LogPlanServer. As a resource
of that server, it may be located in a logical and arbitrary sub-directory
(i.e. the sub-directory need not exist). For example:
<pre>http://xxx.www.zzz:5555/Demo/UIDebug/MyStuff/PlanElements.PSP</pre>
Note that the resource is located in a "directory" Demo/UIDebug/MyStuff.
Note that the resource name has a .PSP suffix. This is mandatory.
<p>The corresponding PSP must have identified itself using the setResourceLocation
method defined in the PSP_BaseAdapter class. For example, the PSP that
matches the above query would have declared itself using:
<pre>setResourceLocation("/Demo/UIDebug/MyStuff", "PlanElements.PSP")</pre>
The other model, is that PSPs are "asked" if they want to respond to an
incoming service request. In this form they "test" the incoming URL parameter
set or POST data and decide if they want to respond. While this feature
is supported in the LogPlanServer implementation, it is not expected to
be commonly used at this time. If this feature is not used, then the test()
method on the PSP need not be implemented.
<p>The server can ask every PSP without regard to their location (as a
resource of the server) if they are interested in handling a particular
service request. This will happen if the ?PSP URL parameter is contained.
PSPs are asked in no particular order. This implies there can be no overlap
at this time in a PSP's "interests". A PSP may examine the requestor's
URL parameters or POST data for query or client-state information which
it may use to determine its reaction. This approach is intended for use
by a community of PSP developers who have developed a set of shareable,
interacting PSPs using an established protocol for query.
<br><!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Querying a Single PSP</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>A single PSP which is directly referenced may choose to test URL parameters
or POST data and decide what to return as a document based on these inputs.
A simple example is of a PSP which obtains query information via URL paramters
or POST data and "queries" the LogPlan and from the query results decides
what to return.
<p>Such a PSP will implement the query and document generation logic within
the body of the execute() method. Example, given:
<pre>http://xxx.www.zzz:5555/Demo/UIDebug/MyStuff/PlanElements.PSP?TYPE=ALLOCATIONS?STARTDATE=11_13_98</pre>
An execute method may contain a switch ...
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute(...){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if STARTDATE BETWEEN XXX AND YYYY THEN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ELSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Using The PSP_BaseAdapter</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>If you are not implementing the test() method (ie. relying on evoking
PSP by direct reference only) AND you are using the PSP_BaseAdapter, then
the test() should be disabled, in this manner:
<pre>&nbsp;&nbsp;&nbsp; public boolean test(HttpInput query_parameters, PlanServiceContext sc)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.initializeTest(); // Must call if subclass off of PSP_BaseAdapter.java
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp; // This PSP is only accessed by direct reference...
&nbsp;&nbsp;&nbsp; }</pre>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
The HTTPInput Interface</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>An HTTPInput instance is provided to PlanServiceProviders when test()
or execute() are called.
<p>The HTTPInput instance is a helper class instance which provides to
PlanServiceProviders a higher-level API for querying and retrieving URL
parameters and POST data. The interface sketched here is illustrative and
is subject to change. The current interface allows the PSP developer to
easily:
<pre>1. Query for a specific target URL parameter.&nbsp;
&nbsp;&nbsp; Example. existsParameter("HELP") tests for existence of ?HELP

2. Obtain a set of tokens from a URL parameter string. Where a token is a substring delimited by a delimiting character.&nbsp;
&nbsp;&nbsp; Example. getParameterTokens("BAR",'=') returns a Vector containing A, B, C, D when presented with&nbsp;
&nbsp;&nbsp; the URL ?BAR =A =B =C =D

3. Obtain a value that has been embedded in a token substring within a URL parameter string.&nbsp;
&nbsp;&nbsp; Example. getParameterTokenAsValuePair("FOO", '_', "MYID=") would return 123 when presented with&nbsp;
&nbsp;&nbsp; the URL ?FOO_MYNAME=JOHN_MYID=123_MYFRIEND=MARY</pre>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Exception handling within the "execute()" method</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>A PSP which generates a java runtime exception during the course of
execution automatically causes an HTML document containing the exception
message and the stack trace to be returned to the client. Thus, the client
receives both a browser-readable text message, as well as a stack trace.
<p>PSP developers may also choose to throw a RuntimePSPException rather
than an Exception. When a PSP throws a RuntimePSPException, ONLY the exception
message is returned to the client without HTML wrapping. This is useful
to PSPs which have established a private exception handling protocol with
their client, e.g. returning error codes, etc.
<p>Likewise, a client application which converses with a PSP may choose
to define a private ASCII protocol which is parsed by the client from the
returned ASCII stream. While it need not be wrapped as HTML, doing so offers
greater opportunities for debugging/developing as browsers can be stimulated
by PSPs and their return examined.
<p>Example: an illustration error trap:
<blockquote>execute(...){ // test 1... ...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// test 2... ...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// test 3...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// oops! failed out.print(" ERRORCODE10 "); // error-code wrapped in HTML
tags
<br>}</blockquote>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Implementation of Long-lived or "Keep-Alive" PSPs</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>A "Keep-alive" PSP is one which implements the KeepAlive.java interface.&nbsp;
This is a marker interface (no signatures).&nbsp; Otherwise, a Keep-alive
PSP appears&nbsp; like a regular PSP.&nbsp; However, since a Keep-alive
PSP is one which is allowed to continuously execute (ie. hold a connection
output stream open indefinitely, there are some sublties in implementation
which need to reflect this different behavior.
<p>1.) If the PSP throws an Exception or RuntimePSPException... the connection
is terminated.&nbsp; Behavior then defaults to the general PSP response
of returning either exception stack trace as HTML document (java.lang.exception)&nbsp;
and/or proprietary text message (RuntimePSPException).&nbsp; See section
on Exceptions and PSPs.
<p>2.) The server, in order to trap&nbsp; long-running PSPs which are orphaned
(client disappeared) and are mute for long periods of time (ie. trigger/monitor
based PSPs), will periodically send an "&lt;ACK>" text message to the client
over the outputstream.&nbsp; There are 2 consequences of this:
<p>2.a) UI clients using long-lived PSP connections, should anticipate
and filter out periodic "&lt;ACK>" messages.
<br>2.b) The Keep-alive PSP is responsible for enforcing 'atomicity' of
its output -- ie. a&nbsp; message is not fragmented by an&nbsp; inopportune
"&lt;ACK>" inserted by PSP manager.&nbsp;&nbsp; It can do this by synchronizing
on the stream during output of message.&nbsp; However, it MUST relinquish
control of the stream after writing each message.&nbsp; In other words
DO NOT synchronize upon the outputstream and never release its monitor!
<p>execute(...)
<br>{
<br>&nbsp;&nbsp;&nbsp;&nbsp; while( true ) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // test if need to take
action and return message...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( test() ) {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
synchronized( out )
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// say something...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
out.println("&lt;HTML>Hello world&lt;/HTML>");
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // sleep for a while
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
<br>&nbsp;&nbsp; }
<br>&nbsp;}
<br>&nbsp;
<br>&nbsp;
<p>Generally, "Keep-alive" PSPs monitor for some change of state in the
Cluster LogPlan.&nbsp; Such a PSP needs to implement&nbsp; the UISubscriber.java
interface.&nbsp; In the current implementation, such a&nbsp; PSP will need
to to the following:
<p>1.) register a subscription for LogPlan objects of interest (see Cluster
documentation on predicates and LogPlan)
<br>2.) implement a call-back which is called by the PlanServerPlugIn when
new LogPlan objects which pass the predicate test are noted.&nbsp; To do
this effectively, there are several considerations.
<p>2.a) you need to define your own predicate and register it.
<br>2.b) you need to provide your working container (Vector) and handle
it in manner safe for multi-threaded environment.
<br>2.c) You need to periodically "wake-up" in execute method and "poll"
to see if new content added to your container.
<p>See below for example.
<p><font color="#3333FF">Note.&nbsp; This implementation may be changed
-- to be based on a wait/notify model for efficiency.&nbsp; It should not
dramatically alter your code -- except to streamline some of the control
logic, per below.</font>
<br>&nbsp;
<p>execute() {
<br>&nbsp;&nbsp;&nbsp; UIsubscribe(myPredicate);
<br>&nbsp;&nbsp;&nbsp; while(true)
<br>&nbsp;&nbsp;&nbsp; {
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized(incomingAlerts){
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// if new elements, process...
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if( incomingAlerts.size() > 0 )
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// do something
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// flush changes vector
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
incomingAlerts.setSize(0);
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<br>&nbsp; }
<br>}
<br>//&nbsp; PlugIn call-back … called when registered subscription is
updated via CCv2
<br>&nbsp;public void subscriptionChanged(Subscription subscription) {
<br>&nbsp;synchronized(incomingAlerts) {
<br>&nbsp;&nbsp;&nbsp;&nbsp; Enumeration e = ((IncrementalSubscription)subscription).getAddedList();
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// if elements, add to incomingAlerts vector
<br>&nbsp;&nbsp;&nbsp; }
<br>&nbsp;}
<br>&nbsp;
<p><!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
Passing Data to a PSP</h2>
<!--  ############################################################################ --><!--  ############################################################################ --><!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
An application which opens a connection to a PSP and POSTS data</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<pre>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; // Open up URL to your PSP...
&nbsp;&nbsp;&nbsp;&nbsp; URL url = new URL('http://localhost:5555/DEMO/SCENARIO1/NATE.PSP');
&nbsp;&nbsp;&nbsp;&nbsp; // Obtain URL connection
&nbsp;&nbsp;&nbsp;&nbsp; URLConnection uc = url.openConnection();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; uc.setDoOutput(true);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; OutputStream os = uc.getOutputStream();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; PrintStream servicePrint = new PrintStream(os);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; String postmsg = "123456789 RANDOMTEXT";
&nbsp;&nbsp;&nbsp;&nbsp; // Write to the output stream associated with that connection&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; servicePrint.println(postmsg);</pre>
What is sent to the server looks something like this...
<pre>&nbsp;&nbsp;&nbsp;&nbsp; POST /?PLAN_MYPSP HTTP/1.0
&nbsp;&nbsp;&nbsp;&nbsp; User-Agent: Java1.1.6
&nbsp;&nbsp;&nbsp;&nbsp; Host: localhost:5555
&nbsp;&nbsp;&nbsp;&nbsp; Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
&nbsp;&nbsp;&nbsp;&nbsp; Connection: keep-alive
&nbsp;&nbsp;&nbsp;&nbsp; Content-type: application/x-www-form-urlencoded
&nbsp;&nbsp;&nbsp;&nbsp; Content-length: 23

&nbsp;&nbsp;&nbsp;&nbsp; 123456789&nbsp; RANDOMTEXT</pre>
And what has been sent is extracted at PSP by way of....
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public void execute( PrintStream out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpInput query_parameters,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PlanServiceContext psc,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PlanServiceUtilities psu ) throws Exception, RuntimeThrowableSLPMessage
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String postData = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( query_parameters.getPostData() != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postData = new String(query_parameters.getPostData());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // postData = "123456789 RANDOMTEXT"
}</pre>
<!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
The Debugging User Interface: An Example PlanServiceProvider</h2>
<!--  ############################################################################ --><!--  ############################################################################ --><!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<h3>
Overview</h3>
<!--  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p>One model for the implementation of a PSP is the debugging user interface
(UI). At the cluster end, the debugging UI comprises three primary classes:
<ul>
<li>
The cluster level PlugIn (called PlanServerPlugIn)</li>

<li>
The LogPlanServer</li>

<li>
The debugging PlanServiceProvider (PSP)</li>
</ul>
These classes interact as follows. The PlanServerPlugIn provides three
basic functions.
<ul>
<li>
It is a cluster level plugin.</li>

<li>
It creates and starts the LogPlanServer and the PSP.</li>

<li>
It provides subscription services to the PSP.</li>
</ul>
The Log Plan Server:
<ul>
<li>
Gets requests from users via HTTP connections and sends them to the correct
PSP.</li>
</ul>
The PSP:
<ul>
<li>
Gets requests from users via the LogPlanServer.</li>

<li>
Enters subscriptions for log plan objects via the PlanServerPlugIn.</li>

<li>
Creates XML for the log plan objects and sends this via the HTTP connection
to the user.</li>
</ul>

<h3>
PlanServerPlugIn</h3>
In its role as a cluster level plugin, PlanServerPlugIn extends org.cougaar.plugin.SimplifiedPlugIn,
and hence it must implement 2 abstract methods:
<ul>
<li>
setUpSubscriptions which creates and launches the LogPlanServer, creates
and launches the debugging PSP, and registers the debugging PSP with the
LogPlanServer</li>

<li>
execute which is called by the cluster infrastructure whenever a subscription
is changed, and calls the PSP which submitted that subscription</li>
</ul>
In order to provide subscription services to the PSP, the PlanServerPlugIn
implements the ServerPlugInSupport interface, and hence it must implement
3 methods:
<ul>
<li>
subscribe which accepts a predicate from a PSP and enters a subscription
on behalf of the PSP</li>

<li>
unsubscribeForSubscriber which accepts a Subscription from a PSP and removes
it from the active subscription list</li>

<li>
getClusterIDAsString which returns the cluster identifier as a string</li>
</ul>

<h3>
LogPlanServer</h3>
The LogPlanServer calls the PSP execute method when an appropriate request
is received from the user (as described above). The LogPlanServer passes
the PlanServerPlugIn to the PSP (in the PlanServiceContext object which
is a paramter of the execute method). Hence, the PSP "discovers" the PlanServerPlugIn
class that will provide support for entering subscriptions on the log plan.
<h3>
PSP</h3>
In the execute method, the PSP parses the request from the user, composes
and submits a subscription using the PlanServerPlugIn.subscribe method,
converts the log plan objects from the subscription to XML, and returns
the XML to the user via the HTTP connection.
<p>In addition, a long lived PSP, receives subscription notifications from
the PlanServerPlugIn via the UISubscriber.subscriptionChanged interface,
and sends these to the user.
<br><!--  ############################################################################ --><!--  ############################################################################ -->
<h2>
Applets</h2>
<!--  ############################################################################ --><!--  ############################################################################ -->
<p>PSP developers can write applets that obtain information from their
PSPs. Because of applet security restrictions, adapting an APPLICATION
that converses with a PSP into an APPLET that converses with the PSP can
be a bit tricky. The problem is that the APPLET and the cluster with which
it communicates must appear to come from the same URL in order to pass
security restrictions. To address this problem, the LogPlanServer provides
a proxy service. The proxy service receives a request from a user, for
example, a request to load an applet, and passes that request to a real
web server. The applet is then returned from the web server, through the
LogPlanServer, to the user's browser. When the user subsequently uses the
applet to query the PSP in the cluster, it appears as though the query
is going to the same URL (the cluster) from which the applet was loaded.
To produce an applet that communicates with a PSP, follow these steps.
<ol>Create an applet to communicate with your PSP, for example, XMLApplet.
Create a jar file containing the applet class and any associated classes,
for example, ui.jar. If you are using swing, you will also need to include
a jar file of the swing classes, for example, swingall.jar. And if you
are using an xml parser, you will also need to include a jar file for the
xmlparser, for example, xmlparser.jar.
<li>
Create an html document to run your applet. The applet code parameter must
specify the complete package name of the applet, in the example, ui.planviewer.
The applet archive parameter must specify a list of the jar files needed
to run the applet. A sample HTML file that invokes the applet would be:</li>

<blockquote>&lt;html> &lt;head>&lt;title>XML Applet&lt;/title>&lt;/head>
&lt;body> &lt;applet CODE="ui.planviewer.XMLApplet" ARCHIVE="ui.jar, swingall.jar,
xml.jar" WIDTH=700 HEIGHT=400> &lt;/applet> &lt;/body> &lt;/html></blockquote>

<li>
Place the jar files and the html file in the appropriate directory on the
web server. For example, if the web server was www.alpine.com and it served
files from the HTML directory, then you might create a directory for your
files, for example, HTML/test, and place the jar files and the above HTML
file in that directory:</li>

<pre>Directory listing of HTML/test on www.alpine.com:
ui.jar
swingall.jar
xml.jar
xmlapplet.html</pre>

<li>
To load the applet, first establish a proxy connection with the LogPlanServer.
For example, if the cluster was running on "www.fairview.com", the LogPlanServer
was listening on port 5555 (the default), and the web server was located
at "www.alpine.com", enter the following in your browser:</li>

<pre>http://www.fairview.com:5555/?PROXY?START?URL=http://www.alpine.com/test
Next, load the applet:
http://www.fairview.com:5555/xmlapplet.html</pre>
The applet can then send queries and receive responses from PSPs accessed
via the LogPlanServer on fairview at port 5555.</ol>

<h3>
&nbsp;</h3>

<h3>
<font face=""><font size=+2>CookBook and CheckList:&nbsp; Writing a PSP
fast!</font></font></h3>

<pre><font face=""><font color="#0000FF"><font size=+1>0.)&nbsp; Set-up/configure LogPlanServers for society

</font></font></font>0.1) Make sure UI PlugIns are loaded in Cluster.ini files:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "plugin = ui.xmlservice.PlanServerPlugIn"

0.2)&nbsp; from wherever you launch your society (Node), be sure to place copy of
help.html (obtain from: external.alpine.planserver)... enables u to evoke ?help&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "http://localhost:5555?help"


1.) The fastest way to "cook-book" a PSP is to take an existing cougaar PSP and copy it.&nbsp; Example:

copy ui.xmlservice.PSP_PolicyEditor&nbsp;&nbsp;&nbsp; [located at external/alpine/ui ]


<font face=""><font color="#0000FF"><font size=+1>2.) Basic Implementation</font></font></font>






</pre>

<pre>public class PSP_PolicyEditor extends PSP_BaseAdapter implements
PlanServiceProvider, UISubscriber

2.a) UISUBSCRIBER INTERFACE&nbsp;





</pre>

<pre>UISubscriber => see UI Architecture Slides 22 June PDW, page titled "Appendix: Long-Lived PSPs" for
example pattern.&nbsp;&nbsp; Two components:&nbsp; PSP calls subscribe to identify LogPlan objects of interest&nbsp;
(Cluster/CCv2 predicate semantics)and implement call-back.&nbsp; PSP implements call-back method by which it is notified of&nbsp;
LogPlan objects matching its subscription which have changed.

2.b) BEHAVIORS/IMPLEMENTATION REQUIRED:

test() method should be stubbed out w/following code:
&nbsp;"super.initializeTest();
&nbsp;&nbsp;&nbsp; return false; "

2.c) ADD IMPLEMENTATION/BEHAVIOR TO execute().


<font face=""><font color="#0000FF"><font size=+1>3.) Integrate PSP into LogPlanServer

</font></font></font>3.1) Add Hard-code PSPs into your Development LogPlanServer:

To compile your PSP into LogPlanServers within your development environment,&nbsp;
goto ui.xmlservice.PlanServerLauncher&nbsp; look for where PSPs instances are added into LPS and
insert your own, example:

planServer.getPSPHarness().addPlanProvider(new
PSP_EditPSPBlackBoard_1("alpine/demo","EBB.PSP") );

In the above example:&nbsp;

"alpine/demo" => represents the "resource path" of psp at server
"EBB.PSP"&nbsp; => actual alias of PSP.

The above arguments are case-sensitive.

3.2) Add PSPs dynamically into LogPlanServer ... consult ?help for url command syntax.

3.3) Confirm addition by querying LogPlanServer, eg:

<a href="http://localhost:5555?LIST?PSP">http://localhost:5555?LIST?PSP</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==> list all PSPs loaded at
this server

3.4) Society sanity check.&nbsp; List all LogPlanServers and their cluster IDs
within society, eg:

<a href="http://localhost:5555/alpine/demo/CLUSTERS.PSP">http://localhost:5555/alpine/demo/CLUSTERS.PSP</a>&nbsp; =>&nbsp; note this should&nbsp;
list all LogPlanServers (Clusters) that have been registered with name service.





</pre>

<pre>Copyright 1999 BBN Systems and Technologies, A Division of BBN Corporation; 10 Moulton Street, Cambridge, MA 02138 (617) 873-3000</pre>

</body>
</html>
