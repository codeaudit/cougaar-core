<HTML>
<HEAD>
<title> Message Transport 8.3 Design Notes</title>
</HEAD>
<body>
<h2>Message Transport 8.3 Design Notes</h2>
<p>
<h3>Overview:</h3>

The Cougaar Message Transport has been dramatically refactored for
Release 8.3. The problem addressed is that several independent groups
will be adding features and adaptive code to the Message Transport for
Release 8.4. Also at runtime, a Cougaar society needs to pick and
choose between these features, based on policies and resource
status. The message transport features to be added include: Dependability
(OBJS), Security (NAI), Performance (BBN QuO), and  Dynamic Agents (BBN
CSMART).

<p> 

The solution is to break the Message Transport into many
micro-services, which together implement a basic message transport.
Each development group will extend the base-implementation, by
creating "aspect" objects, each which implements a specific feature.
At runtime, the aspect objects will be added or removed from
base-implementation. The mechanism for dynamically adding aspect
objects is based on a specialized version of the Ultralog
component-model and the Aspect-Oriented programming concept of
cross-cutting. Details are described below.

<p>

The component-model with the cross-cutting extensions will enable a
full featured Cougaar Message Transport to be composed from pieces
supplied by independent groups. Independent development and composition
will greatly improve maintenance of the Cougaar code, because the
whole message transport does not have to be modified to add each
feature, as was the case with Cougaar 8.0. The sevice model must be
extended for the message transport, because each group needs to add
just a little code to all the services.

<p>

The 8.3 refactoring of the message transport should expose all the
necessary hooks to implement the features needed for Cougaar 8.4. We
expect a round of feedback from the different development groups,
before the service interfaces are fixed in Release 8.3.1.


<p>

<h3>Introduction:</h3> 

The Message Transport is divided into into a dozen services.  The
services are decomposed to match the basic functionality of
transporting a message from one agent to another. In the typical case,
in which all the services are setup and no errors have occurred, the
messages flow smoothly from one service to the next. In this case the
architecture looks like over-kill, because most services act as simple
pass-through. But a closer look shows that at each juncture where an
error or a special case can occur, a interface (or hook) is
exposed. Extra code can be added at these interfaces to handle the
special cases. Past experience with communication systems show that
95% of the code is used to handling special cases, even though 99.9%
of the forwarded messages go through the system without needing
special handling.


<p>

The basic services are described in the "top view" diagram. The message
flows from the Sending Agent into the
Router service the picks a destination link. The destination link
moves the message to the remote Node, using one of several Transport
schemes, such as email, rmi, loopback, or raw sockets. The receiving
Node then directs the message to the local destination Agent. Along
the way the message is queued and filtered to allow hooks for
different features to be added. The Java Doc describes the Interfaces
for these services.

<P><IMG SRC="MTtop.gif"></P>

The "side view" of the Services show how the services are created and
where the features are allowed to hook in. The architecture explicitly
breaks up the runtime adaptation into different times:

<ul>
<li>

<b>BindTime</b> The MessageTransportServiceImpl.java will instantiated
by the Node as a component, (not quite implemented for 8.3).  The
MessageTransportServiceImpl is a substrate on which all the MT
services are created and managed. At Bind-time  several things are
created, the Service Factories, The MessageTransports (email, rmi,
etc), the MessageTransportAspects, and a few of the singleton services
(e.g. router, registry, namesupport).

</li>

<li>
<b>Service-lookup time </b> Most Services are created on demand. The
Receive Links are made when Local Agents register with the society. 
The First-call to a
Destination Agent will make the DestinationLink services. In the future, 
message failure can cause the services to be re-looked-up.
<p>
When a service is created the service factory is called. A service
factory calls each of the Aspects to see if they have a Delegate (or
ServiceProxy) for its interface. The factory then strings together all
the delegates and the base service. The factory returns a reference to
the outer most delegate. Delegates give Apsects a way of hooking into
flow of messages.
</li>

<li>
<b>Message-forwarding time</b> After all the services are hooked
together, the message is forward thought the chain of services and
their delegates. Delegates can call back to their Aspect and
manipulate the Aspect's state or access outside services, such as the
QoS Monitoring Service. 

</li>

</ul>



<P><IMG SRC="MTside.gif"></P>
</body>
</HTML>



<h3>Creating an Aspect for your Message Transport:</h3> 

Two example aspects are given. WatcherAspect.java and
TraceAspect.java. We will be dividing up the
rmi/RMIMesssageTransport.java and MesssageTransportClassic.java into
aspects for Release 8.3.1. These classes will no longer exist for
Release 8.3.1.

<p>

The rmi/SimpleRMIMesssageTransport.java shows the base implementation
for a message transport. Notice that MessageTransport now only
implements the moving of a message to a specific destination. It does
NOT contain all the destination and receive queuing, which was part of
the MessageTransport in 8.2.

<p>


<h3>Running an Aspect for your Message Transport:</h3> 

The Node script must be modified to enable the new MessageTransports
and Aspects.
<p><p>
To specify which Aspects to load set the Java system
property org.cougaar.message.transport.aspects. (See
MessageTransportServiceImpl.java). 
<p>
COUGAAR_JAVA_ARGS="-Dorg.cougaar.message.transport.aspects=org.cougaar.core.society.TraceAspect,org.cougaar.core.society.WatcherAspect"
<p><p>
To specify which Transport to load is is done using the Java system
property org.cougaar.message.transportClasses. (See
MessageTransportFactory.java). 
COUGAAR_JAVA_ARGS="-Dorg.cougaar.message.transportClasses=org.cougaar.core.society.rmi.SimpleRMIMessageTransport,org.cougaar.core.society.EmailMessageTransport"

<p><p>
To run the Simple message transport set True the Java system
property "org.cougaar.core.society.UseSimpleRMI" (See
MessageTransportFactory.java). 
<p>
COUGAAR_JAVA_ARGS="-Dorg.cougaar.core.society.UseSimpleRMI=true"

